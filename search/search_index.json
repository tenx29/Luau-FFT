{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Luau FFT Luau FFT is an open-source module for calculating discrete Fourier transforms on Roblox. The module includes an object-oriented implementation of complex numbers to assist with the required calculations. Info Basic understanding of Luau and object-oriented programming is assumed in this documentation. Performance notice The Fourier transform is a very time-intensive task, so it is not recommended to use this on Roblox for real-time applications with very large input tables.","title":"About"},{"location":"#about-luau-fft","text":"Luau FFT is an open-source module for calculating discrete Fourier transforms on Roblox. The module includes an object-oriented implementation of complex numbers to assist with the required calculations. Info Basic understanding of Luau and object-oriented programming is assumed in this documentation. Performance notice The Fourier transform is a very time-intensive task, so it is not recommended to use this on Roblox for real-time applications with very large input tables.","title":"About Luau FFT"},{"location":"api-reference/cmath/","text":"Complex Mathematics cmath is a class used for calculations using complex numbers. This module is necessary when calculating Fourier transforms, but it can be used for a lot of other purposes as well. Required by another script This module must have the same Parent as the Fourier module . Creating a new complex number ComplexNumber cmath.new( float real? , float imag? ) Creates a new Complex Number object. real is the real component and imag is the imaginary component. ComplexNumber cmath.fromDict( dict { float Real?, float Imag?} ) Creates a new Complex Number object using a dictionary instead of two separate arguments. Properties float Real The real component of the Complex Number. float Imag The imaginary component of the Complex Number. Methods float , float polar() Returns the polar representation of a Complex Number. First number is the distance from origin (magnitude) and the second is the phase angle in radians. Magnitude is calculated using the abs method. Phase angle is calculated with $$ \\theta=\\mathrm{atan2}\\left(b{,}\\ a\\right) $$ ComplexNumber exp() Returns e (approximately 2.7182818) raised to the power of a Complex Number. Uses the formula $$ e^z=e^a\\cos b+ie^a\\sin b{,}\\ \\mathrm{where}\\ z=a+bi\\ \\mathrm{and}\\ a{,}\\ b\\in\\mathbb{R} $$ float abs() Returns the absolute value (distance from origin) of a Complex Number with $$ \\left|z\\right|=\\sqrt{a^2+b^2}{,}\\ \\mathrm{where}\\ z=a+bi\\ \\mathrm{and}\\ a{,}\\ b\\in\\mathbb{R} $$ Important When performing comparisons < , > , <= and >= with complex numbers, the absolute value is used as there is no universally accepted way to compare complex numbers with each other. When using the == comparison, the real and complex components are compared individually. Mathematical operations This section lists all mathematical operations supported by Complex Numbers. In this section \\(z\\) and \\(w\\) can both be either complex or real numbers. When necessary, real number inputs are automatically converted to complex numbers. In the following examples, \\(z=a+bi\\) and \\(w=c+di\\) , where \\(a{,}\\ b{,}\\ c{,}\\ d\\in \\mathbb{R}\\) . Addition and subtraction To perform addition or subtraction with complex numbers, you can simply use z+w and z-w in your code. The formula used for this is $$ z+w=a+c+(b+d)i $$ Multiplication Multiplication is also supported using the standard * operator. This module performs complex multiplication as follows: $$ z\\cdot w=\\left(ac-bd\\right)+\\left(ad+bc\\right)i $$ Division Division can be done using the / operator for any \\(z\\) and \\(w\\) . Division uses the following formula: $$ \\frac{z}{w}=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i $$ Exponentiation Exponentiation can be done using the ^ operator for any \\(z\\) and \\(w\\) . The result is calculated as follows: $$ z^w=e^{\\log r\\left(c+di\\right)+\\theta i\\left(c+di\\right)} $$ where \\(r\\) and \\(\\theta\\) are the magnitude and phase angle of the polar representation of the base.","title":"Complex Mathematics"},{"location":"api-reference/cmath/#complex-mathematics","text":"cmath is a class used for calculations using complex numbers. This module is necessary when calculating Fourier transforms, but it can be used for a lot of other purposes as well. Required by another script This module must have the same Parent as the Fourier module .","title":"Complex Mathematics"},{"location":"api-reference/cmath/#creating-a-new-complex-number","text":"","title":"Creating a new complex number"},{"location":"api-reference/cmath/#complexnumber-cmathnewfloat-real-float-imag","text":"Creates a new Complex Number object. real is the real component and imag is the imaginary component.","title":"ComplexNumber cmath.new(float real?, float imag?)"},{"location":"api-reference/cmath/#complexnumber-cmathfromdictdict-float-real-float-imag","text":"Creates a new Complex Number object using a dictionary instead of two separate arguments.","title":"ComplexNumber cmath.fromDict(dict {float Real?, float Imag?})"},{"location":"api-reference/cmath/#properties","text":"","title":"Properties"},{"location":"api-reference/cmath/#float-real","text":"The real component of the Complex Number.","title":"float Real"},{"location":"api-reference/cmath/#float-imag","text":"The imaginary component of the Complex Number.","title":"float Imag"},{"location":"api-reference/cmath/#methods","text":"","title":"Methods"},{"location":"api-reference/cmath/#float-float-polar","text":"Returns the polar representation of a Complex Number. First number is the distance from origin (magnitude) and the second is the phase angle in radians. Magnitude is calculated using the abs method. Phase angle is calculated with $$ \\theta=\\mathrm{atan2}\\left(b{,}\\ a\\right) $$","title":"float, float polar()"},{"location":"api-reference/cmath/#complexnumber-exp","text":"Returns e (approximately 2.7182818) raised to the power of a Complex Number. Uses the formula $$ e^z=e^a\\cos b+ie^a\\sin b{,}\\ \\mathrm{where}\\ z=a+bi\\ \\mathrm{and}\\ a{,}\\ b\\in\\mathbb{R} $$","title":"ComplexNumber exp()"},{"location":"api-reference/cmath/#float-abs","text":"Returns the absolute value (distance from origin) of a Complex Number with $$ \\left|z\\right|=\\sqrt{a^2+b^2}{,}\\ \\mathrm{where}\\ z=a+bi\\ \\mathrm{and}\\ a{,}\\ b\\in\\mathbb{R} $$ Important When performing comparisons < , > , <= and >= with complex numbers, the absolute value is used as there is no universally accepted way to compare complex numbers with each other. When using the == comparison, the real and complex components are compared individually.","title":"float abs()"},{"location":"api-reference/cmath/#mathematical-operations","text":"This section lists all mathematical operations supported by Complex Numbers. In this section \\(z\\) and \\(w\\) can both be either complex or real numbers. When necessary, real number inputs are automatically converted to complex numbers. In the following examples, \\(z=a+bi\\) and \\(w=c+di\\) , where \\(a{,}\\ b{,}\\ c{,}\\ d\\in \\mathbb{R}\\) .","title":"Mathematical operations"},{"location":"api-reference/cmath/#addition-and-subtraction","text":"To perform addition or subtraction with complex numbers, you can simply use z+w and z-w in your code. The formula used for this is $$ z+w=a+c+(b+d)i $$","title":"Addition and subtraction"},{"location":"api-reference/cmath/#multiplication","text":"Multiplication is also supported using the standard * operator. This module performs complex multiplication as follows: $$ z\\cdot w=\\left(ac-bd\\right)+\\left(ad+bc\\right)i $$","title":"Multiplication"},{"location":"api-reference/cmath/#division","text":"Division can be done using the / operator for any \\(z\\) and \\(w\\) . Division uses the following formula: $$ \\frac{z}{w}=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i $$","title":"Division"},{"location":"api-reference/cmath/#exponentiation","text":"Exponentiation can be done using the ^ operator for any \\(z\\) and \\(w\\) . The result is calculated as follows: $$ z^w=e^{\\log r\\left(c+di\\right)+\\theta i\\left(c+di\\right)} $$ where \\(r\\) and \\(\\theta\\) are the magnitude and phase angle of the polar representation of the base.","title":"Exponentiation"},{"location":"api-reference/cmath/#_1","text":"","title":""},{"location":"api-reference/fourier/","text":"Fourier The Fourier module has two different methods you can use for performing discrete Fourier transforms. Dependency This module needs to perform calculations with complex numbers and must therefore have the same Parent as the Complex Number module . What is a Fourier transform? Warning This section is me trying my best to explain how the module works, but I'm not a professional. If you wish to learn more about Fourier transforms, ask someone with a degree. According to Wikipedia , a Fourier transform is a mathematical transform that decomposes functions depending on space or time into functions depending on spatial frequency or temporal frequency. In simpler terms, it can be used to find out the intensity of sine waves of various frequencies that can be used to construct virtually any function. A common use for this is to calculate the frequency spectrum of a group of audio samples for audio visualization. Ideally, a Fourier transform of a function would be calculated as \\[ \\mathcal{F[f(x)](y)=\\int_{-\\infty}^{\\infty}f\\left(x\\right)e^{-2\\pi ixy}\\ dx} \\] However, because usually we don't need the symbolic solution (or don't have the computing power, memory or time to calculate it), this module uses something known as the discrete Fourier transform , which is the numeric equivalent for the Fourier transform using a finite set of samples with equal spacing. For this reason we use a different formula: $$ X_k=\\sum_{n=0}^{N-1}x_n\\cdot e^{-\\frac{2\\pi i}{N}kn} $$ where \\(X\\) is the sequence of output frequencies, \\(k\\) is the frequency, or the index of the intensity value \\(X_k\\) \\(x\\) is the sequence of input samples, \\(N\\) is the amount of input samples, \\(n\\) is the current sample being iterated over. The result is a fairly good approximation of the input signal's Fourier transform which is good enough for most purposes. Functions Important The tables returned by dft and fft have the DC term of the Fourier transform at an index of 0. Other values are indexed normally by frequency. table dft( table samples , integer maxFrequency? , boolean getAbsolute? ) Returns the discrete Fourier transform of the sample list samples . All samples must be real or complex numbers. The maxFrequency determines the maximum frequency calculated by the DFT algorithm. ( \\(N/2\\) by default, where \\(N\\) is the amount of samples) If getAbsolute is true , the complex values in the result table are converted into real numbers based on their magnitudes. Note If you need the conjugate data to be included in the result, set maxFrequency to the amount of samples. Performance notice Discrete Fourier transform has a time complexity of \\(n^2\\) , which means calculating the DFT of large input sample tables may be slow. table fft( table samples , boolean ignoreConjugate? , boolean getAbsolute? ) Returns the fast Fourier transform of the sample list samples using the Cooley-Tukey FFT algorithm . Returns a result similar to DFT, but is a faster algorithm and is therefore more suitable for larger data sets. If ignoreConjugate is true , the conjugate data will be automatically cut off from the spectrum. If getAbsolute is true , the FFT will automatically be converted into its real counterpart similar to dft . Performance notice Fast Fourier transform has a time complexity of \\(n \\log{n}\\) , which means calculating the FFT of extremely large input sample tables may be slow.","title":"Fourier"},{"location":"api-reference/fourier/#fourier","text":"The Fourier module has two different methods you can use for performing discrete Fourier transforms. Dependency This module needs to perform calculations with complex numbers and must therefore have the same Parent as the Complex Number module .","title":"Fourier"},{"location":"api-reference/fourier/#what-is-a-fourier-transform","text":"Warning This section is me trying my best to explain how the module works, but I'm not a professional. If you wish to learn more about Fourier transforms, ask someone with a degree. According to Wikipedia , a Fourier transform is a mathematical transform that decomposes functions depending on space or time into functions depending on spatial frequency or temporal frequency. In simpler terms, it can be used to find out the intensity of sine waves of various frequencies that can be used to construct virtually any function. A common use for this is to calculate the frequency spectrum of a group of audio samples for audio visualization. Ideally, a Fourier transform of a function would be calculated as \\[ \\mathcal{F[f(x)](y)=\\int_{-\\infty}^{\\infty}f\\left(x\\right)e^{-2\\pi ixy}\\ dx} \\] However, because usually we don't need the symbolic solution (or don't have the computing power, memory or time to calculate it), this module uses something known as the discrete Fourier transform , which is the numeric equivalent for the Fourier transform using a finite set of samples with equal spacing. For this reason we use a different formula: $$ X_k=\\sum_{n=0}^{N-1}x_n\\cdot e^{-\\frac{2\\pi i}{N}kn} $$ where \\(X\\) is the sequence of output frequencies, \\(k\\) is the frequency, or the index of the intensity value \\(X_k\\) \\(x\\) is the sequence of input samples, \\(N\\) is the amount of input samples, \\(n\\) is the current sample being iterated over. The result is a fairly good approximation of the input signal's Fourier transform which is good enough for most purposes.","title":"What is a Fourier transform?"},{"location":"api-reference/fourier/#functions","text":"Important The tables returned by dft and fft have the DC term of the Fourier transform at an index of 0. Other values are indexed normally by frequency.","title":"Functions"},{"location":"api-reference/fourier/#table-dfttable-samples-integer-maxfrequency-boolean-getabsolute","text":"Returns the discrete Fourier transform of the sample list samples . All samples must be real or complex numbers. The maxFrequency determines the maximum frequency calculated by the DFT algorithm. ( \\(N/2\\) by default, where \\(N\\) is the amount of samples) If getAbsolute is true , the complex values in the result table are converted into real numbers based on their magnitudes. Note If you need the conjugate data to be included in the result, set maxFrequency to the amount of samples. Performance notice Discrete Fourier transform has a time complexity of \\(n^2\\) , which means calculating the DFT of large input sample tables may be slow.","title":"table dft(table samples, integer maxFrequency?, boolean getAbsolute?)"},{"location":"api-reference/fourier/#table-ffttable-samples-boolean-ignoreconjugate-boolean-getabsolute","text":"Returns the fast Fourier transform of the sample list samples using the Cooley-Tukey FFT algorithm . Returns a result similar to DFT, but is a faster algorithm and is therefore more suitable for larger data sets. If ignoreConjugate is true , the conjugate data will be automatically cut off from the spectrum. If getAbsolute is true , the FFT will automatically be converted into its real counterpart similar to dft . Performance notice Fast Fourier transform has a time complexity of \\(n \\log{n}\\) , which means calculating the FFT of extremely large input sample tables may be slow.","title":"table fft(table samples, boolean ignoreConjugate?, boolean getAbsolute?)"}]}